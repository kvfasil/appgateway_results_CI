name: Extract Test Artifacts and Push to Branch

on:
  push:
    paths:
      - 'artifacts/*.tar.gz'
    branches:
      - 'RDKEMW*'   # trigger on ALL branches (Jira branches)

permissions:
  contents: write

jobs:
  extract-and-push:
    runs-on: ubuntu-latest
    # Skip if the push was made by github-actions[bot] to prevent infinite loops
    if: github.actor != 'github-actions[bot]'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    # pull lates in case multiple pushes happened quickly
    - name: Pull latest changes
      run: |
        echo "[INFO] Pulling latest changes for branch ${{ github.ref_name }}"
        git pull origin "${{ github.ref_name }}"  

    - name: Extract artifact and push results to branch
      shell: /usr/bin/bash --noprofile --norc -e -o pipefail {0}
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -euo pipefail  # Add at start of script blocks

        # --------------------------------------------------
        # Determine branch name for push event
        # --------------------------------------------------
        BRANCH="${GITHUB_REF_NAME}"

        if [ -z "$BRANCH" ]; then
          echo "[ERROR] Could not determine branch name"
          exit 1
        fi

        echo "[INFO] Branch detected: $BRANCH"

        # --------------------------------------------------
        # Locate and extract latest artifact tarball in repo
        # --------------------------------------------------
        mkdir -p extracted
        # Prefer release artifacts if present; else use develop.
        # Order candidates by timestamp embedded in filename: <type>_YYYYMMDD_HHMMSS.tar.gz
        ls artifacts/ || {
          echo "[ERROR]: No artifacts/ directory found"
          exit 1
        }

        # Find the latest artifact tar.gz file
        LATEST_NAME=$(ls -1 artifacts/*.tar.gz 2>/dev/null | sort | tail -n1 | xargs -n1 basename)
        if [ -z "$LATEST_NAME" ]; then
          echo "[ERROR]: No artifact tarball found under artifacts/"
          exit 1
        fi

        LATEST_ARTIFACT="artifacts/$LATEST_NAME"
        LATEST_TYPE=$(echo "$LATEST_NAME" | cut -d'_' -f1)
        echo "[INFO] Selected $LATEST_TYPE artifact: $LATEST_ARTIFACT"

        if [ -z "$LATEST_ARTIFACT" ]; then
          echo "[ERROR]: No artifact tarball found under artifacts/"
          exit 1
        fi

        # Determine artifact type from filename prefix
        ARTIFACT_TYPE=$(basename "$LATEST_ARTIFACT" | cut -d'_' -f1)
        echo "[INFO] Artifact type detected: $ARTIFACT_TYPE"

        echo "[INFO] Extracting artifact: $LATEST_ARTIFACT"
        tar -xzf "$LATEST_ARTIFACT" -C extracted

        # --------------------------------------------------
        # Generate timestamp from artifact filename (fallback to now)
        # Expected format: <type>_YYYYMMDD_HHMMSS.tar.gz
        # --------------------------------------------------
        ARTIFACT_BASENAME=$(basename "$LATEST_ARTIFACT")
        if [[ "$ARTIFACT_BASENAME" =~ ^${ARTIFACT_TYPE}_([0-9]{8}_[0-9]{6})\.tar\.gz$ ]]; then
          TIMESTAMP="${BASH_REMATCH[1]}"
        else
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          echo "[WARN] Could not parse timestamp from $ARTIFACT_BASENAME; using current time"
        fi
        echo "[INFO] Timestamp: $TIMESTAMP"

        # --------------------------------------------------
        # Resolve proposition from version.txt within extracted artifact
        # --------------------------------------------------
        PROPOSITION="unknown"
        VERSION_FILE=$(find extracted -type f -name 'version.txt' | head -n1 || true)
        if [ -n "${VERSION_FILE:-}" ] && [ -f "$VERSION_FILE" ]; then
          echo "[INFO] Found version file at: $VERSION_FILE"
          IMAGE_LINE=$(grep -i "^imagename" "$VERSION_FILE" || true)
          if [ -n "$IMAGE_LINE" ]; then
            IMAGE_VAL=$(echo "$IMAGE_LINE" | cut -d':' -f2- | xargs)
            if echo "$IMAGE_VAL" | grep -q '_' ; then
              PROPOSITION=$(echo "$IMAGE_VAL" | cut -d'_' -f1)
            else
              PROPOSITION="unknown"
            fi
          fi
        else
          echo "[INFO] version.txt not found in extracted artifacts; using proposition=unknown"
        fi

        echo "[INFO] Proposition resolved as: $PROPOSITION"

        # --------------------------------------------------
        # Prepare output directories per requested structure
        # --------------------------------------------------
        if [ "$ARTIFACT_TYPE" == "develop" ]; then
          ROOT_DIR="develop"
          echo "[INFO] Artifact type is develop; using develop directory structure"
          SUB_ROOT_DIR="$BRANCH"
        else
          ROOT_DIR="release"
          echo "[INFO] Artifact type is release; using release directory structure"

          # grep APPGATEWAY_VERSION from version.txt if present eg:"APPGATEWAY_VERSION=$RELEASE_VERSION"
          RELEASE_VERSION=0.0.0.0
          VERSION_FILE=extracted/version.txt

          if [ -f "$VERSION_FILE" ]; then
            RELEASE_VERSION_LINE=$(grep -i "^APPGATEWAY_VERSION=" "$VERSION_FILE" || true)
            if [ -n "$RELEASE_VERSION_LINE" ]; then
              RELEASE_VERSION=$(echo "$RELEASE_VERSION_LINE" | cut -d'=' -f2 | xargs)
              echo "[INFO] Found APPGATEWAY_VERSION: $RELEASE_VERSION"
            else
              echo "[WARN] APPGATEWAY_VERSION not found in version.txt;"
            fi
          fi

          SUB_ROOT_DIR=$RELEASE_VERSION
        fi

        RESULT_DIR="$ROOT_DIR/$SUB_ROOT_DIR/$PROPOSITION/"
        if [ -d "$RESULT_DIR" ]; then
          echo "[INFO] Result directory $RESULT_DIR already exists; new files will be added under timestamped subdirectory"
        else
          echo "[INFO] Creating result directory: $RESULT_DIR"
          mkdir -p "$RESULT_DIR"
        fi
        TARGET_DIR="$ROOT_DIR/$SUB_ROOT_DIR/$PROPOSITION/$TIMESTAMP"
        mkdir -p "$TARGET_DIR"
        cp -r extracted/* "$TARGET_DIR/"

        rm -rf artifacts || true  # Clean up artifacts to save space

        echo "[INFO] Prepared directories: $RESULT_DIR"

        # Export RESULT_DIR to GITHUB_ENV so subsequent steps can access it
        echo "RESULT_DIR=$RESULT_DIR" >> "$GITHUB_ENV"
        echo "PROPOSITION=$PROPOSITION" >> "$GITHUB_ENV"

        # Remove existing env_variables.txt if present
        # Remove when PR is merged.
        if [ -f env_variables.txt ]; then
          rm env_variables.txt || true
        fi

        echo "RESULT_DIR=$RESULT_DIR" >> "env_variables.txt"
        echo "PROPOSITION=$PROPOSITION" >> "env_variables.txt"
        
        # --------------------------------------------------
        # Push results back to same PR branch using git
        # --------------------------------------------------
        echo "[INFO] Adding files to git for branch $BRANCH"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add "$RESULT_DIR" env_variables.txt artifacts
        if git commit -m "Add extracted artifacts for $BRANCH proposition=$PROPOSITION at $TIMESTAMP"; then
          git push origin HEAD:"$BRANCH"
          echo "✅ Extracted files pushed to branch $BRANCH under $RESULT_DIR using git"
        else
          echo "[INFO] No changes to commit; skipping push"
        fi

    # add job to remove env_variables.txt
    - name: Clean up env_variables.txt
      if: ${{ success() }}
      run: |
        if [ -f env_variables.txt ]; then
          rm env_variables.txt || echo "[WARN] Could not delete env_variables.txt"
        fi

    # add final step if above steps are successful: create a PR and merge the changes into webpage named branch, then delete current branch
    - name: Create PR and merge to webpage branch, then delete current branch (with retry)
      if: ${{ success() }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        BRANCH: ${{ github.ref_name }}
      run: |
        set -euo pipefail
        MAX_RETRIES=2
        RETRY_DELAY=30
        COUNT=0
        SUCCESS=0
        while [ $COUNT -lt $MAX_RETRIES ]; do
          echo "[INFO] Attempt $((COUNT+1)) to merge $BRANCH into webpage"
          git fetch origin webpage || git checkout -b webpage
          git checkout webpage || git checkout -b webpage
          git pull origin webpage || true
          if git merge --no-ff "$BRANCH" -m "Merge $BRANCH into webpage"; then
            if git push origin webpage; then
              SUCCESS=1
              break
            else
              echo "[WARN] Push failed, will retry after $RETRY_DELAY seconds"
            fi
          else
            echo "[WARN] Merge failed, will retry after $RETRY_DELAY seconds"
            git merge --abort || true
          fi
          COUNT=$((COUNT+1))
          sleep $RETRY_DELAY
        done
        if [ $SUCCESS -eq 1 ]; then
          # Delete the source branch from remote if not protected
          if [ "$BRANCH" != "webpage" ]; then
            git push origin --delete "$BRANCH" || echo "[WARN] Could not delete branch $BRANCH (may be protected)"
          fi
          echo "✅ Merged $BRANCH into webpage and deleted $BRANCH"
        else
          echo "❌ Failed to merge $BRANCH into webpage after $MAX_RETRIES attempts. Manual intervention required."
          exit 1
        fi
